import customtkinter as ctk
import threading
import re
import sys
import time
from Backend.GeminiBrain import bot
from Backend.SpeechToText import SpeechRecognition
from Backend.TextToSpeech import TextToSpeech
from Backend.Automation import Automation

# --- Configuration ---
ctk.set_appearance_mode("Light")
ctk.set_default_color_theme("blue")

COLORS = {
    "bg": "#f0f2f5", "sidebar": "#ffffff", "chat_bg": "#f0f2f5",
    "user_bubble": "#2563eb", "bot_bubble": "#ffffff", "input_bg": "#ffffff",
    "text": "#111827", "text_dim": "#6b7280", "accent": "#3b82f6",
    "danger": "#ef4444", "success": "#10b981", "border": "#e5e7eb"
}

# --- 1. SMART CORRECTION (Voice Fix) ---
def smart_correct(text):
    text = " " + text.lower() + " " 
    
    # Strong replacements for common errors
    replacements = {
        " start and ": " start hand ",
        " start ant ": " start hand ",
        " open and ": " start hand ",
        " gas can ": " start hand ",
        " guest con ": " start hand ",
        " start high ": " start eye ",
        " start i ": " start eye ",
        " launch i ": " start eye ",
        " vision ": " eye ",
    }
    
    for bad, good in replacements.items():
        if bad in text:
            text = text.replace(bad, good)
            
    return text.strip()

def clean_markdown(text):
    if not text: return ""
    text = re.sub(r'\*\*(.*?)\*\*', r'\1', text) 
    text = re.sub(r'#{1,6}\s?', '', text)        
    text = re.sub(r'\*(.*?)\*', r'\1', text)     
    text = re.sub(r'`(.*?)`', r'\1', text)       
    return text.strip()

class AestheticApp(ctk.CTk):
    def __init__(self):
        super().__init__()
        self.title("Proton AI")
        self.geometry("1100x750")
        self.configure(fg_color=COLORS["bg"])
        
        self.grid_columnconfigure(1, weight=1)
        self.grid_rowconfigure(0, weight=1)

        # Sidebar
        self.sidebar = ctk.CTkFrame(self, width=240, corner_radius=0, fg_color=COLORS["sidebar"])
        self.sidebar.grid(row=0, column=0, sticky="nsew")
        self.sidebar.grid_rowconfigure(4, weight=1) 

        self.logo = ctk.CTkLabel(self.sidebar, text="PROTON", font=("Segoe UI", 28, "bold"), text_color=COLORS["text"])
        self.logo.grid(row=0, column=0, padx=20, pady=(40, 10), sticky="w")
        
        self.subtitle = ctk.CTkLabel(self.sidebar, text="Virtual Assistant", font=("Segoe UI", 12), text_color=COLORS["text_dim"])
        self.subtitle.grid(row=1, column=0, padx=20, pady=(0, 30), sticky="w")

        self.mic_btn = ctk.CTkButton(
            self.sidebar, text="üé§ Start Mic", font=("Segoe UI", 14, "bold"),
            fg_color=COLORS["bg"], text_color=COLORS["text"], hover_color="#e2e8f0",
            height=50, corner_radius=12, border_width=1, border_color=COLORS["border"],
            command=self.toggle_mic
        )
        self.mic_btn.grid(row=2, column=0, padx=20, pady=10, sticky="ew")

        self.status_frame = ctk.CTkFrame(self.sidebar, fg_color="transparent")
        self.status_frame.grid(row=3, column=0, padx=20, pady=10, sticky="ew")
        self.status_dot = ctk.CTkLabel(self.status_frame, text="‚óè", font=("Arial", 18), text_color=COLORS["success"])
        self.status_dot.pack(side="left", padx=(0, 5))
        self.status_text = ctk.CTkLabel(self.status_frame, text="Online", font=("Segoe UI", 13), text_color=COLORS["text_dim"])
        self.status_text.pack(side="left")

        self.footer = ctk.CTkLabel(self.sidebar, text="v3.4 ‚Ä¢ Hybrid Core", font=("Segoe UI", 10), text_color=COLORS["text_dim"])
        self.footer.grid(row=5, column=0, padx=20, pady=20, sticky="w")

        # Chat Area
        self.chat_area = ctk.CTkScrollableFrame(self, fg_color=COLORS["chat_bg"], corner_radius=0)
        self.chat_area.grid(row=0, column=1, sticky="nsew", padx=0, pady=0)

        # Input Area
        self.input_container = ctk.CTkFrame(self, fg_color=COLORS["bg"], height=80, corner_radius=0)
        self.input_container.grid(row=1, column=1, sticky="ew")
        
        self.input_bg = ctk.CTkFrame(self.input_container, fg_color=COLORS["input_bg"], corner_radius=30, border_width=1, border_color=COLORS["border"])
        self.input_bg.pack(fill="x", expand=True, padx=30, pady=20)

        self.entry = ctk.CTkEntry(
            self.input_bg, placeholder_text="Type a message...", 
            border_width=0, fg_color="transparent", height=50, 
            font=("Segoe UI", 14), text_color=COLORS["text"], placeholder_text_color=COLORS["text_dim"]
        )
        self.entry.pack(side="left", fill="x", expand=True, padx=(20, 10))
        self.entry.bind("<Return>", self.send_text)

        self.send_btn = ctk.CTkButton(
            self.input_bg, text="‚û§", width=50, height=40, 
            fg_color=COLORS["accent"], hover_color="#1d4ed8", corner_radius=20, 
            font=("Arial", 18), text_color="white", command=self.send_text
        )
        self.send_btn.pack(side="right", padx=(0, 10), pady=5)

        self.mic_on = False
        self.add_message("System", "System Ready. Voice commands active.")

    def add_message(self, sender, text):
        clean_text_str = clean_markdown(text)
        if sender == "User":
            align_frame, bubble_color, text_color, margin = "e", COLORS["user_bubble"], "#ffffff", (50, 10)
        elif sender == "Bot":
            align_frame, bubble_color, text_color, margin = "w", COLORS["bot_bubble"], COLORS["text"], (10, 50)
        else: 
            align_frame, bubble_color, text_color, margin = "center", "transparent", COLORS["text_dim"], (10, 10)

        msg_frame = ctk.CTkFrame(self.chat_area, fg_color="transparent")
        msg_frame.pack(anchor=align_frame, pady=5, padx=margin, fill="x")

        bubble = ctk.CTkLabel(
            msg_frame, text=clean_text_str, fg_color=bubble_color, 
            corner_radius=18, wraplength=600, font=("Segoe UI", 15), 
            text_color=text_color, padx=15, pady=10, justify="left"
        )
        if sender == "System": bubble.configure(font=("Segoe UI", 12, "italic"))
        bubble.pack(anchor=align_frame)
        self.update_idletasks()
        self.chat_area._parent_canvas.yview_moveto(1.0)

    def update_status(self, status_msg, color_key="success"):
        self.status_text.configure(text=status_msg)
        self.status_dot.configure(text_color=COLORS.get(color_key, COLORS["success"]))

    def send_text(self, event=None):
        text = self.entry.get()
        if not text: return
        self.entry.delete(0, "end")
        
        final_text = smart_correct(text)
        self.add_message("User", final_text)
        
        # --- 2. HARDCODED INTERCEPTOR (The Fix) ---
        # Check for specific commands BEFORE sending to AI
        low = final_text.lower()
        if "start hand" in low or "launch hand" in low:
            self.add_message("Bot", "Starting Hand Gesture Control...")
            Automation(["OPEN hand"])
            return
            
        if "start eye" in low or "launch eye" in low:
            self.add_message("Bot", "Starting Eye Tracking...")
            Automation(["OPEN eye"])
            return

        if "stop" in low and ("hand" in low or "eye" in low):
            self.add_message("Bot", "Stopping Vision Control...")
            Automation([f"CLOSE {low}"])
            return

        threading.Thread(target=self.process_backend, args=(final_text,), daemon=True).start()

    def process_backend(self, text):
        self.update_status("Thinking...", "accent")
        try:
            response = bot.send_message(text)
            
            if "COMMAND:" in response:
                parts = response.split(":")
                action = parts[1]
                target = parts[2]
                
                if action == "EXIT":
                    self.add_message("Bot", "Goodbye!")
                    TextToSpeech("Goodbye!")
                    self.after(2000, self.destroy)
                    return

                self.update_status(f"Action: {action}", "accent")
                Automation([f"{action} {target}"])
                final_reply = f"‚úÖ I have {action.lower()}ed {target}."
            else:
                final_reply = response

            self.add_message("Bot", final_reply)
            TextToSpeech(clean_markdown(final_reply))
            
        except Exception as e:
            self.add_message("System", f"Error: {e}")
        finally:
            self.update_status("Online", "success")

    def toggle_mic(self):
        self.mic_on = not self.mic_on
        if self.mic_on:
            self.mic_btn.configure(text="‚óè Listening...", fg_color=COLORS["danger"], text_color="white", hover_color="#b91c1c")
            self.update_status("Listening...", "danger")
            threading.Thread(target=self.mic_loop, daemon=True).start()
        else:
            self.mic_btn.configure(text="üé§ Start Mic", fg_color=COLORS["bg"], text_color=COLORS["text"], hover_color="#e2e8f0")
            self.update_status("Online", "success")

    def mic_loop(self):
        while self.mic_on:
            try:
                text = SpeechRecognition()
                if text:
                    corrected = smart_correct(text)
                    self.after(0, lambda: self.entry.delete(0, "end"))
                    self.after(0, lambda: self.entry.insert(0, corrected))
                    self.after(100, lambda: self.send_text())
            except Exception:
                time.sleep(0.1)
                continue

if __name__ == "__main__":
    app = AestheticApp()
    app.mainloop()
